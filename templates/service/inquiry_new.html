{% extends 'base.html' %}
{% block title %}Ø§Ø³ØªÙØ³Ø§Ø± Ø¬Ø¯ÙŠØ¯ | Ù…Ù†ØµØ© Ø·ÙŠØ¨Ø© Ø§Ù„ØµÙˆØªÙŠØ©{% endblock %}

{% block content %}
<div class="page-head">
  <nav class="breadcrumb" aria-label="Ø§Ù„ØªÙ†Ù‚Ù„">
    <a href="{% url 'service:dashboard' %}">Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</a>
    <span class="separator">â€º</span>
    <span>Ø§Ø³ØªÙØ³Ø§Ø± Ø¬Ø¯ÙŠØ¯</span>
  </nav>
  <h1>Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªÙØ³Ø§Ø± Ø¬Ø¯ÙŠØ¯</h1>
  <p class="muted">ÙŠÙ…ÙƒÙ†Ùƒ ÙƒØªØ§Ø¨Ø© Ø³Ø¤Ø§Ù„Ùƒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„ØµÙˆØªÙŠ Ø£Ùˆ Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØªÙŠ.</p>
</div>

<div class="card">
  <form method="post" enctype="multipart/form-data" class="form" id="inquiry-form">
    {% csrf_token %}

    {{ form.non_field_errors }}

    <div class="form-row">
      <label for="{{ form.title.id_for_label }}">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø± *</label>
      {{ form.title }}
      {{ form.title.errors }}
      <p class="field-hint">Ø§ÙƒØªØ¨ Ø¹Ù†ÙˆØ§Ù†Ø§Ù‹ Ù…Ø®ØªØµØ±Ø§Ù‹ ÙŠØµÙ Ø³Ø¤Ø§Ù„Ùƒ</p>
    </div>

    <div class="form-row">
      <label for="{{ form.question_text.id_for_label }}">Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„</label>
      {{ form.question_text }}
      {{ form.question_text.errors }}
      <p class="field-hint">Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„ØµÙˆØªÙŠ Ø£Ø¯Ù†Ø§Ù‡ØŒ Ø£Ùˆ Ø§Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØªÙŠ</p>
    </div>

    <!-- ===== Voice Recognition (STT) Panel ===== -->
    <div class="stt-panel card" id="stt-panel">
      <h3>ğŸ¤ Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„ØµÙˆØªÙŠ</h3>
      <p class="hint">ØªØ­Ø¯Ø« ÙˆØ³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ ÙƒÙ„Ø§Ù…Ùƒ Ø¥Ù„Ù‰ Ù†Øµ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹. ÙŠØ¯Ø¹Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙˆØ§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.</p>

      <!-- Language selector -->
      <div class="tts-setting-group">
        <span class="tts-setting-label">Ø§Ù„Ù„ØºØ©:</span>
        <div class="voice-selector" role="radiogroup" aria-label="Ù„ØºØ© Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡">
          <label class="voice-option selected">
            <input type="radio" name="stt-lang" value="ar-SA" checked>
            <span>ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</span>
          </label>
          <label class="voice-option">
            <input type="radio" name="stt-lang" value="en-US">
            <span>ğŸ‡ºğŸ‡¸ English</span>
          </label>
        </div>
      </div>

      <!-- STT controls -->
      <div class="stt-controls">
        <button type="button" id="stt-start" class="btn primary stt-btn" aria-label="Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„">
          ğŸ¤ Ø³Ø¬Ù‘Ù„ (Ø³Ø¬Ù„)
        </button>
        <button type="button" id="stt-stop" class="btn danger stt-btn" disabled aria-label="Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„">
          â¹ ØªÙˆÙ‚Ù‘Ù (ØªÙˆÙ‚Ù)
        </button>
      </div>

      <!-- Status indicator -->
      <div id="stt-status" class="stt-status hidden" role="status" aria-live="polite">
        <span class="stt-pulse"></span>
        <span id="stt-status-text">Ø¬Ø§Ù‡Ø²</span>
      </div>

      <!-- Voice commands hint -->
      <div class="stt-commands-hint">
        <strong>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØµÙˆØªÙŠØ©:</strong>
        <span class="stt-cmd">Â«Ø³Ø¬Ù‘Ù„Â»</span> Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ &nbsp;
        <span class="stt-cmd">Â«ØªÙˆÙ‚Ù‘ÙÂ»</span> Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„ &nbsp;
        <span class="stt-cmd">Â«Ø£Ø±Ø³Ù„Â»</span> Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±
      </div>
    </div>

    <div class="form-row">
      <label for="{{ form.question_audio.id_for_label }}">Ù…Ù„Ù ØµÙˆØªÙŠ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
      <div class="file-upload-wrapper">
        {{ form.question_audio }}
        <p class="field-hint">Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©: MP3, WAV, OGG, M4A, WebM (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)</p>
      </div>
      {{ form.question_audio.errors }}
    </div>

    <div class="form-row">
      <label for="{{ form.priority.id_for_label }}">Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©</label>
      {{ form.priority }}
      {{ form.priority.errors }}
    </div>

    <div class="form-actions">
      <button class="btn primary" type="submit" id="submit-btn">Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±</button>
      <a class="btn outline" href="{% url 'service:dashboard' %}">Ø¥Ù„ØºØ§Ø¡</a>
    </div>
  </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
(function() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    // Hide STT panel if not supported
    const panel = document.getElementById('stt-panel');
    if (panel) {
      panel.innerHTML = '<p class="hint">âš ï¸ Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Chrome Ø£Ùˆ Edge.</p>';
    }
    return;
  }

  const startBtn = document.getElementById('stt-start');
  const stopBtn = document.getElementById('stt-stop');
  const statusDiv = document.getElementById('stt-status');
  const statusText = document.getElementById('stt-status-text');
  const textArea = document.getElementById('{{ form.question_text.id_for_label }}');
  const submitBtn = document.getElementById('submit-btn');
  const form = document.getElementById('inquiry-form');

  let recognition = null;
  let isListening = false;
  let commandMode = false; // Always-on listener for voice commands

  // â”€â”€â”€â”€ Voice selector sync â”€â”€â”€â”€
  document.querySelectorAll('input[name="stt-lang"]').forEach(r => {
    r.addEventListener('change', function() {
      document.querySelectorAll('[name="stt-lang"]').forEach(radio => {
        radio.closest('.voice-option')?.classList.remove('selected');
      });
      this.closest('.voice-option')?.classList.add('selected');
      // Update recognition language if active
      if (recognition && isListening) {
        stopListening();
        setTimeout(startListening, 300);
      }
    });
  });

  function getLang() {
    const el = document.querySelector('input[name="stt-lang"]:checked');
    return el ? el.value : 'ar-SA';
  }

  // â”€â”€â”€â”€ Core STT â”€â”€â”€â”€
  function createRecognition() {
    const rec = new SpeechRecognition();
    rec.lang = getLang();
    rec.continuous = true;
    rec.interimResults = true;
    rec.maxAlternatives = 1;
    return rec;
  }

  function startListening() {
    if (isListening) return;

    recognition = createRecognition();

    recognition.onstart = () => {
      isListening = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      startBtn.classList.add('recording');
      statusDiv.classList.remove('hidden');
      statusText.textContent = 'ğŸ”´ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹... ØªØ­Ø¯Ø« Ø§Ù„Ø¢Ù†';
    };

    recognition.onresult = (e) => {
      let interim = '';
      let final = '';

      for (let i = e.resultIndex; i < e.results.length; i++) {
        const transcript = e.results[i][0].transcript;
        if (e.results[i].isFinal) {
          final += transcript;
        } else {
          interim += transcript;
        }
      }

      // Check for voice commands in final text
      if (final) {
        const cmd = checkVoiceCommand(final.trim());
        if (cmd) return; // Command handled, don't add to text

        // Append to text area
        const current = textArea.value;
        const sep = current && !current.endsWith(' ') && !current.endsWith('\n') ? ' ' : '';
        textArea.value = current + sep + final.trim();
        textArea.dispatchEvent(new Event('input', { bubbles: true }));
      }

      // Show interim in status
      if (interim) {
        statusText.textContent = 'ğŸ”´ ' + interim;
      }
    };

    recognition.onerror = (e) => {
      console.error('STT Error:', e.error);
      if (e.error === 'no-speech') {
        statusText.textContent = 'âš ï¸ Ù„Ù… ÙŠØªÙ… Ø±ØµØ¯ ÙƒÙ„Ø§Ù…. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
      } else if (e.error === 'not-allowed') {
        statusText.textContent = 'âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.';
      } else {
        statusText.textContent = 'âš ï¸ Ø®Ø·Ø£: ' + e.error;
      }
      setTimeout(() => { if (!isListening) statusDiv.classList.add('hidden'); }, 3000);
    };

    recognition.onend = () => {
      // Auto-restart if still supposed to be listening
      if (isListening) {
        try { recognition.start(); } catch(e) { stopListening(); }
        return;
      }
      stopListening();
    };

    try {
      recognition.start();
    } catch(e) {
      statusText.textContent = 'âš ï¸ ØªØ¹Ø°Ø± Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª.';
      statusDiv.classList.remove('hidden');
    }
  }

  function stopListening() {
    isListening = false;
    if (recognition) {
      try { recognition.stop(); } catch(e) {}
      recognition = null;
    }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    startBtn.classList.remove('recording');
    statusText.textContent = 'â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„';
    setTimeout(() => statusDiv.classList.add('hidden'), 2000);
  }

  // â”€â”€â”€â”€ Voice commands â”€â”€â”€â”€
  function checkVoiceCommand(text) {
    const normalized = text.replace(/[Ù‹ÙŒÙÙÙÙÙ‘Ù’]/g, '').trim();

    // "Ø³Ø¬Ù„" variants â†’ start recording
    if (/^(Ø³Ø¬Ù„|Ø³Ø¬Ù‘Ù„|Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¬ÙŠÙ„|Ø§Ø¨Ø¯Ø£|record|start)/i.test(normalized)) {
      startListening();
      return true;
    }
    // "ØªÙˆÙ‚Ù" variants â†’ stop recording
    if (/^(ØªÙˆÙ‚Ù|ØªÙˆÙ‚Ù‘Ù|Ù‚Ù|ÙˆÙ‚Ù|stop)/i.test(normalized)) {
      stopListening();
      return true;
    }
    // "Ø£Ø±Ø³Ù„" variants â†’ submit form
    if (/^(Ø£Ø±Ø³Ù„|Ø§Ø±Ø³Ù„|Ø¥Ø±Ø³Ø§Ù„|Ø§Ø¨Ø¹Ø«|send|submit)/i.test(normalized)) {
      stopListening();
      statusText.textContent = 'ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±...';
      statusDiv.classList.remove('hidden');
      setTimeout(() => form.submit(), 500);
      return true;
    }
    return false;
  }

  // â”€â”€â”€â”€ Button handlers â”€â”€â”€â”€
  startBtn.addEventListener('click', startListening);
  stopBtn.addEventListener('click', stopListening);

  // â”€â”€â”€â”€ Always-on command listener â”€â”€â”€â”€
  // A lightweight listener that just waits for voice commands even when not in dictation mode
  let commandRecognition = null;

  function startCommandListener() {
    if (!SpeechRecognition) return;
    if (commandRecognition) return;

    commandRecognition = new SpeechRecognition();
    commandRecognition.lang = 'ar-SA';
    commandRecognition.continuous = true;
    commandRecognition.interimResults = false;

    commandRecognition.onresult = (e) => {
      for (let i = e.resultIndex; i < e.results.length; i++) {
        if (e.results[i].isFinal) {
          const text = e.results[i][0].transcript.trim();
          // Only handle commands, not dictation
          if (!isListening) {
            checkVoiceCommand(text);
          }
        }
      }
    };

    commandRecognition.onend = () => {
      // Restart if not in full dictation mode
      if (!isListening && commandRecognition) {
        try { commandRecognition.start(); } catch(e) {}
      }
    };

    commandRecognition.onerror = () => {
      // Silently restart
      if (!isListening) {
        setTimeout(() => {
          if (commandRecognition) {
            try { commandRecognition.start(); } catch(e) {}
          }
        }, 1000);
      }
    };

    // Don't auto-start command listener - it requires user gesture
    // Instead, start it on first interaction with the page
  }

  // Start command listener on first click anywhere on the page
  let commandListenerStarted = false;
  document.addEventListener('click', function initCommandListener() {
    if (commandListenerStarted) return;
    commandListenerStarted = true;
    startCommandListener();
    if (commandRecognition && !isListening) {
      try { commandRecognition.start(); } catch(e) {}
    }
  }, { once: false });
})();
</script>
{% endblock %}
